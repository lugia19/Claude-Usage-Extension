// shared/dataclasses.js - Single source of truth for data classes
// Content script version is generated by scripts/build-dataclasses.js

import { CONFIG } from '../bg-components/utils.js';

export class UsageData {
	constructor(data = {}) {
		// Each limit: { percentage, resetsAt } or null
		this.limits = {
			session: data.limits?.session || null,      // five_hour
			weekly: data.limits?.weekly || null,         // seven_day
			sonnetWeekly: data.limits?.sonnetWeekly || null,  // seven_day_sonnet (Max only)
			opusWeekly: data.limits?.opusWeekly || null       // seven_day_opus (Max only)
		};
		this.subscriptionTier = data.subscriptionTier || 'claude_free';
	}

	static fromAPIResponse(apiResponse, subscriptionTier) {
		const parseLimit = (obj) => obj ? {
			percentage: obj.utilization,
			resetsAt: new Date(obj.resets_at).getTime()
		} : null;

		return new UsageData({
			limits: {
				session: parseLimit(apiResponse.five_hour),
				weekly: parseLimit(apiResponse.seven_day),
				sonnetWeekly: parseLimit(apiResponse.seven_day_sonnet),
				opusWeekly: parseLimit(apiResponse.seven_day_opus)
			},
			subscriptionTier
		});
	}

	// Convert % to estimated tokens remaining for a limit
	getEstimatedTokensRemaining(limitKey) {
		const limit = this.limits[limitKey];
		if (!limit) return null;

		const cap = CONFIG.ESTIMATED_CAPS?.[this.subscriptionTier]?.[limitKey];
		if (!cap) return null;

		return ((100 - limit.percentage) / 100) * cap;
	}

	// Find which limit will run out first given a message cost
	getLimitingFactor(messageCost) {
		if (!messageCost || messageCost <= 0) return null;

		let minMessages = Infinity;
		let limitingKey = null;

		for (const [key, limit] of Object.entries(this.limits)) {
			if (!limit) continue;

			const tokensRemaining = this.getEstimatedTokensRemaining(key);
			if (tokensRemaining === null) continue;

			const messagesLeft = tokensRemaining / messageCost;
			if (messagesLeft < minMessages) {
				minMessages = messagesLeft;
				limitingKey = key;
			}
		}

		return limitingKey ? { key: limitingKey, messagesLeft: minMessages } : null;
	}

	// Get all active limits for sidebar display
	getActiveLimits() {
		return Object.entries(this.limits)
			.filter(([_, limit]) => limit !== null)
			.map(([key, limit]) => ({ key, ...limit }));
	}

	// Get limits that are at 100% (for notification scheduling)
	getMaxedLimits() {
		return this.getActiveLimits().filter(limit => limit.percentage >= 100);
	}

	// For chat area: most constraining weekly-type limit (for marker)
	// model: optional model name string (e.g. "Sonnet", "Opus") to filter relevant limits
	getBindingWeeklyLimit(model) {
		const keys = ['weekly'];
		if (model) {
			const m = model.toLowerCase();
			if (m.includes('sonnet')) keys.push('sonnetWeekly');
			if (m.includes('opus')) keys.push('opusWeekly');
		} else {
			keys.push('sonnetWeekly', 'opusWeekly');
		}


		let candidates = keys
			.map(key => this.limits[key] ? { key, ...this.limits[key] } : null)
			.filter(Boolean);

		if (candidates.length === 0) return null;
		return candidates.reduce((a, b) => a.percentage > b.percentage ? a : b);
	}

	// Session reset info for countdown display
	getSessionResetInfo() {
		const session = this.limits.session;
		if (!session) return null;
		return {
			timestamp: session.resetsAt,
			expired: session.resetsAt <= Date.now()
		};
	}

	toJSON() {
		return {
			limits: this.limits,
			subscriptionTier: this.subscriptionTier
		};
	}

	static fromJSON(json) {
		return new UsageData(json);
	}
}

export class ConversationData {
	constructor(data = {}) {
		this.conversationId = data.conversationId;
		this.messages = data.messages || [];

		// Calculated metrics
		this.length = data.length || 0;  // Total tokens in conversation
		this.cost = data.cost || 0;		 // Token cost (with caching possibly considered)
		this.uncachedCost = data.uncachedCost || 0;       // Without caching
		this.futureCost = data.futureCost || 0; // Estimated cost of future messages
		this.uncachedFutureCost = data.uncachedFutureCost || 0; // Estimated future cost without caching
		this.model = data.model || 'Sonnet';

		// Cache status
		this.costUsedCache = data.costUsedCache || false;	//Currently unused, since now we show future_cost rather than past cost
		this.conversationIsCachedUntil = data.conversationIsCachedUntil || null;

		// Associated metadata
		this.projectUuid = data.projectUuid || null;
		this.styleId = data.styleId || null;
		this.settings = data.settings || {};
		this.lastMessageTimestamp = data.lastMessageTimestamp || null; // Timestamp of the last message in the conversation
		this.lengthIsEstimate = data.lengthIsEstimate || false; // True if length may be inaccurate due to features
	}

	// Add helper method to check if currently cached
	isCurrentlyCached() {
		return this.conversationIsCachedUntil && this.conversationIsCachedUntil > Date.now();
	}

	// Add method to get time until cache expires
	getTimeUntilCacheExpires() {
		if (!this.conversationIsCachedUntil) return null;

		const now = Date.now();
		const diff = this.conversationIsCachedUntil - now;

		if (diff <= 0) return { expired: true, minutes: 0 };

		return {
			expired: false,
			minutes: Math.ceil(diff / (1000 * 60))  // Round up to nearest minute
		};
	}


	// Calculate weighted cost based on model
	getWeightedCost(modelOverride) {
		let model = this.model;
		if (modelOverride) model = modelOverride;
		const weight = CONFIG.MODEL_WEIGHTS[model] || CONFIG.MODEL_WEIGHTS["Sonnet"];
		return Math.round(this.cost * weight);
	}

	getWeightedFutureCost(modelOverride) {
		let model = this.model;
		if (modelOverride) model = modelOverride;
		const weight = CONFIG.MODEL_WEIGHTS[model] || CONFIG.MODEL_WEIGHTS["Sonnet"];
		return Math.round(this.futureCost * weight);
	}

	// Check if conversation is expensive
	isExpensive() {
		return this.cost >= CONFIG.WARNING.COST;
	}

	// Check if conversation is long
	isLong() {
		return this.length >= CONFIG.WARNING.LENGTH;
	}

	toJSON() {
		return {
			conversationId: this.conversationId,
			messages: this.messages,
			length: this.length,
			cost: this.cost,
			uncachedCost: this.uncachedCost,
			futureCost: this.futureCost,
			uncachedFutureCost: this.uncachedFutureCost,
			model: this.model,
			costUsedCache: this.costUsedCache,
			conversationIsCachedUntil: this.conversationIsCachedUntil,
			projectUuid: this.projectUuid,
			styleId: this.styleId,
			settings: this.settings,
			lastMessageTimestamp: this.lastMessageTimestamp,
			lengthIsEstimate: this.lengthIsEstimate
		};
	}

	static fromJSON(json) {
		return new ConversationData(json);
	}
}
